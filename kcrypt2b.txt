==================================
    kcrypt2b
==================================

==> 1. Keys

    The key is an ensemble of 16 Mersenne Twister PRNG states. Each state 
is a vector of 624 32-bit integers. The key is generated by probing exactly
624 * 16 * 4 = 39,936 bytes of random data from a cryptographically secure
random number source.

==> 2. Buffer encryption and decryption

    Buffers are encrypted by processing 16-byte blocks sequentually. Due to
the fact that the block encryption function probes the key and executes the
MT19937 algorithm on each of the 16 states, blocks are naturally chained and
the internal states are recycled every 624 outputs via the twist mechanic.
    Because the operation on the encoder and decoder is symmetric, the same
(predictable) random data is being generated from the key, letting us
reconstruct the original message in presence of the key.

==> 3. Block cipher

    The block cipher begins by dividing the whole GF(256) into three regions,
where [a, b) denotes an interval from a inclusive to b exclusive:

/--------------\/-----------------\/-------------------------------\
 [0         16)  [32           48)  [48                        255)
    message         key padding              sampling area

    We begin by sampling 16 bytes from the key. Each 16 Mersenne twister
states are instructed to generate 16 32-bit words of data each, resulting
in a 16x16 matrix of random data. According to the Mersenne Twister website,
available here:

  http://www.math.sci.hiroshima-u.ac.jp/m-mat/MT/efaq.html

    It is possible to make the Mersenne Twister pseudo-random number
generator cryptographically secure by applying a compression function with
good diffusion properties. Indeed, otherwise, after observing 624
consecutive outputs of each generator, it would have been possible to 
predict all of the future outputs of the generator, making the block cipher
inherently unsafe. However, given that we practically discard 98.4% of the
outputs, the author believes that the internal state of the pseudo-random
number generator can not be recovered.

    The compression function is given by the following formula, assuming
that S is a 16x16 matrix of 32-bit integers obtained by sampling MT19937 and
Sbox is a constant 16x16 matrix of 8-bit integers with satisfactory diffusive
properties.

  f = diag((S * sbox)^r * sbox)

    The matrix S is multiplied by the Sbox matrix, then its rows are rotated
according to the row index, and finally the matrix is multiplied by the Sbox
matrix again. The leading diagonal of the matrix is then the result.

    After the padding vector has been obtained, we construct a function such
that for all x in [0, 16) we have f(x) = data[x] and for x in [16, 32) we
have f(x) = padding[x - 16]. Then, using the means of Lagrange interpolation
in GF(256), we obtain a polynomial which passes through all of these points.

    In the next step, we consider the function f(x) = x + 32 as a vector on
the domain [0, 244) and shuffle it via the means of the Fisher-Yates perfect
shuffle algorithm, sampling directly from the MT19937. The author believes
that this causes minimal amounts of state leakage.

    Finally, the polynomial is evaluated at the first 16 elements of the
point vector (hence, effectively, it is evaluated at a random, shuffled
subset of the domain [32, 256)). The evaluation results are the ciphertext.

    The decryption process is the inverse of the encryption process. It
begins by generating padding from the key and then shuffling the domain
[0, 244) using the Fisher-Yates shuffle algorithm. This gives us a vector
of 32 points the values of which are known (they are either the padding or
the ciphertext). We then construct a polynomial which passes through these
points via Lagrange interpolation and evaluate it at the first 16 elements
of the field - [0, 16). The result is the plaintext.

==> 3. Guarantees

    As a matter of fact:
  
- Matrix product is an operation with the computational complexity usually
  implemented as O(n^2) < O(f(x)) <= O(n^3) - e.g. Strassen's algorithm is
  generally better than the naive O(n^3) method. However, the reference
  implementation accepts the cubic time complexity.
- Lagrange interpolation is also nominally an O(n^3) algorithm. That said,
  because we operate in an integral domain, we generally don't care about
  numerical instability which de facto prevents an optimisation to O(n^2)
  complexity in a lot of scientific computing implementations. Such an
  optimisation is present in the reference implementation.

    The algorithm exhibits rather unfortunate running time characteristics,
however, the author believes that a constant time implementation of such a
method would be feasible and thus make the method not inherently insecure
when processing data that is not at rest (due to timing attacks and other
means of information leakage).

    The author believes that the choices of intractable problems made by
kcrypt2b (which stray further away from kcrypt2 in its reliance on the
polynomial reconstruction problem) is interesting and educational. While
programming errors may render a particular implementation insecure, the
author believes that the algorithm itself has a reasonable foundation.
That said, neither kcrypt2 or kcrypt2b have been subject to any kind of
scrutiny and cryptanalysis by third parties, hence its use is strongly
discouraged.
