# kcrypt3
kcrypt3 - an experimental cryptosystem based on the NP-hard polynomial
reconstruction problem. Released to the public domain by Kamila
Szewczyk - see COPYING.

Project homepage: https://github.com/kspalaiologos/kcrypt3

## Building

```
# If using a git clone (not needed for source packages), first...
$ ./bootstrap

# All...
$ ./configure
$ make
$ sudo make install
```

## Disclaimer

You know what they say about rolling your own crypto. I find the idea
of novel cryptographic systems interesting and I enjoy tinkering with it,
but there is no guarantee that this program is even remotely secure.
In fact it is likely that it is not, due to the fact that it has not been
independently reviewed for problems as mundane as unintended code bugs, let
alone issues with the code idea or specification.

Even if this program and the underlying idea was secure, it is extremely
slow. Encoding and decoding are performed, on my machine, at the rate of
about 500KiB/s.

## Algorithm description

### Block cipher

KCrypt3 principially operates in GF(256) generated by the polynomial 0x1D.
The block cipher is a function that combines the IV, key and the plaintext
to produce the ciphertext. The plaintext and ciphertext are 32 bytes in
length. The key is a tuple of 16 32-bit integers (which denote the
*combining state*) and a 1300-bit integer (the *permutation*).
The encryption algorithm builds the following association table between
the inputs and outputs to a polynomial over GF(256):

```
0     1     2     ...  32    33    34    35    36    ... 40       ...
in[0] in[1] in[2]      IV[0] IV[1] IV[2] IV[3] K3[0][0]  K3[0][3]
```

In total, three leading components of K3 (the combining state) are used
to construct this degree-48 polynomial. Then, we perform Lagrange
interpolation to obtain the concrete coefficients of this polynomial.

Via the unisolvence theroem, this polynomial is uniquely identified by
48 points that lie on it. Hence, we use the *permutation* in an inverse
Cantor expansion (the factoriadic number system) to map the 1300-bit
index to a concrete shuffle of the remaining 208 elements of GF(256).
Then, the last 32 elements of this shuffle are taken and the polynomial
is evaluated at these points using the Horner schema. The resulting
vector of 32 elements is the ciphertext.

The decryption process operates as follows. First we build the following
association table:

```
32    33    34    35    36    ... 40       ...
IV[0] IV[1] IV[2] IV[3] K3[0][0]  K3[0][3]
```

The IV and the combining state points give us the necessary twelve points
to uniquely identify the polynomial. Then, we reconstruct the permutation
from the index in a manner symmetric to the encoder. This gives us a
vector of 48 points that lie on the original polynomial. The points are
then interpolated via Lagrange interpolation and sampled at points between
0 and 32 to obtain the plaintext.

### Stream cipher

The correct use of the block cipher is tricky. The permutation needs to
drastically change for each block and the combining state needs to be
permuted to avoid the situation where the same polynomial is ascribed to
two indistinguishable plaintext blocks.

Regardless of the mode of operation, after each block is processed, the
key is *advanced* as follows:

- The IV (32-bit) is incremented.
- The permutation (1300-bit) is rotated left by one bit and incremented.
  This leads to significant diffusion of the permutation.
- The combining state is advanced as a linear feedback shift register with
  the CRC32-C polynomial (0x1EDC6F41).
- The combining state is rotated to allow the use of new values in subsequent
  blocks.

Then, each mode of operation (CBC, OFB or others) is responsible for
executing the block encryption and key advancement procedures, outside of
the specific functionality of a given mode of operation (like chaining).

### Use as a random number generator

Cryptographically secure random number generators are trivially constructed
from symmetric block ciphers by first sampling a cryprographically secure
randomness source for the (short) key and inserting zero bytes into the
block cipher.

The use of block ciphers in the CTR mode (like AES-CTR) generally does not
yield sufficient diffusion of the zero bytes. This is why the DieHarder
random number generator testing suite prefers to use AES-OFB. The same
principle applies to KCrypt3 and the use of KCrypt3-OFB is recommended.

### Use as a hash function

Follows from a standard Merkle-Damgard construction. It has however certain
requirements from the block cipher that may not be satisfied by KCrypt3.
Such construction has not yet been implemented in the mainline.

### Security

The author believes that KCrypt3 is secure for data at rest. The author
further believes that the main sources of potential insecurity in the cipher
would stem from the application of differential cryptoanalysis and attempts
of simultaineously recovering both parts of the encryption key. It is easy
to demonstrate that recovering either part of the key can be done given the
other and the security of the cipher relies on the fact that recovering
both at the same time is infeasible.

The three issues faced are insufficient diffusion of stream cipher parameters
in key advancement, naive block key derivation and the lack of a formal
security proof.

Prior versions of KCrypt3 used permutation increments instead of the current
rotation-increment combination, which rendered itself insecure to
simultaineous key recovery attacks: the permutation remained constant for
initial few elements of the Galois field, which allowed partial recovery of
the key with the use of an encrypting oracle and a RS-algorithm that corrects
up to Singleton bound, e.g. Shuhong Gao's EEA-based algorithm.

It is possible that future advancements in coding theory, and in particular
probabilistic list decoding methods will make this algorithm (and the McEliece
cryptosystem) practically insecure and obsolete.

### Derivation

The algorithm was derived by the author while studying RS-codes. It is clear
that correcting RS-codes up to the Singleton bound is an easy problem.
However, in the original paper due to Reed and Solomon it is claimed that
the RS-codes can be corrected up to the n-k bound (via naive enumeration).
Such naive enumeration is prohibitively costly, however it is theoretically
feasible and probabilistic algorithms like list decoding can already be used
to correct RS-codes to capacities beyond the Singleton bound.

Seeing this, the author realised that a cryptographic system can be built
on top of the RS-codes. The input message would be encoded with the
non-systematic RS-code (to prevent plaintext leakage) and then corrupted
with a key-derived error vector. Without the key, the message would be
practically unrecoverable as doing so would be equivalent to solving the
practically difficult and NP-hard problem of polynomial reconstruction.

The McEliece cryptosystem, which the author was not aware of at the
time of initial work on KCrypt3, works on a similar premise. It is
an assymetric system that uses Goppa codes and further relies on the
indistinguishability of the Goppa code generator matrix from a general
linear code generator matrix. While believed secure, recent work has
shown that this problem may be tractable. Similarly, McEliece-derived
systems have been proven vulnerable to attacks that exploit the
generator matrix structures of other linear codes, like BCH-codes and
RS-codes. The author however believes that this is not an issue for
KCrypt3, as the assumption on indistinguishability is not made by this
cipher.

### Performance

The block cipher is quadratic at its core and its theoretical performance
can not be improved, unless a sub-quadratic algorithm for polynomial
interpolation is used.

