// Work in progress, might suck, subject to change.
// Uses a slightly different algorithm which I did not have the time
// to document yet.
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
// ========================================================
// Prelude.
// ========================================================
#define Fi(n, a...)for(int i=0;i<n;i++){a;}
#define Fj(n, a...)for(int j=0;j<n;j++){a;}
#define Fk(n, a...)for(int k=0;k<n;k++){a;}
#define Fid(n, a...)for(int i=n-1;i>=0;i--){a;}
#define Fid1(n, a...)for(int i=n-1;i>0;i--){a;}
#define Fj(n, a...)for(int j=0;j<n;j++){a;}
#define XCH(k,x,y){k t=x;x=y;y=t;};
#define _(a...) {return({a;});}
#define S static
#define V void
// GF(2^8) generated by 0x1D, MT19937.
typedef uint8_t u8;   typedef uint16_t u16;
typedef uint32_t u32; typedef uint64_t u64;
S u8 M[256][256], D[256], LOG[256], EXP[510];   S FILE * rng;
S V init() {
  int b = 1;  rng = fopen("/dev/random", "rb");
  Fi(255, LOG[b] = i;  EXP[i] = EXP[i + 255] = b;
          if ((b <<= 1) >= 256) b = (b - 256) ^ 0x1D)
  Fi(256, Fj(256, if (i && j) M[i][j] = EXP[LOG[i] + LOG[j]]))
  Fi(256, int d = LOG[1] - LOG[i]; D[i] = EXP[d < 0 ? d + 255 : d])}
S int cleanup()_(fclose(rng))
typedef struct { u32 mt[624], mti; } key;
S u32 mtn(key * k) {
  u32 y, mag01[2] = { 0, 0x9908b0df };
  if (k->mti >= 624) {
    Fi(227, y = (k->mt[i] & 0x80000000) | (k->mt[i + 1] & 0x7fffffff);
            k->mt[i] = k->mt[i + 397] ^ (y >> 1) ^ mag01[y & 1])
    Fi(396, y = (k->mt[i + 227] & 0x80000000) | (k->mt[i + 228] & 0x7fffffff);
            k->mt[i + 227] = k->mt[i] ^ (y >> 1) ^ mag01[y & 1])
    y = (k->mt[623] & 0x80000000) | (k->mt[0] & 0x7fffffff);
    k->mt[623] = k->mt[396] ^ (y >> 1) ^ mag01[y & 1]; k->mti = 0;
  }
  y = k->mt[k->mti++];         y ^= y >> 11;
  y ^= (y << 7) & 0x9d2c5680;  y ^= (y << 15) & 0xefc60000;
  return y ^ (y >> 18);}
// ========================================================
// http://www.math.sci.hiroshima-u.ac.jp/m-mat/MT/efaq.html
// ========================================================
S void rotl16(u32 * r, int d) {
  u32 t[16]; Fi(16, t[i] = r[(i + d) % 16]); memcpy(r, t, 64);}
S u32 triple32(u32 x) { // exact bias: 0.020888578919738908
  x ^= x >> 17; x *= 0xed5ad4bbU;
  x ^= x >> 11; x *= 0xac4c1b51U;
  x ^= x >> 15; x *= 0x31848babU;
  x ^= x >> 14; return x;}
// Nyberg K. (1991) Perfect nonlinear S-boxes
// TODO: Use MDS code matrix for diffusion?
#define ROTL8(x,s) ((u8) (x << s) | (x >> (8 - s)))
S V initialize_sbox(u8 sbox[256]) {
  u8 p = 1, q = 1;
  do {
    p = p ^ (p << 1) ^ (p & 0x80 ? 0x1B : 0);
    q ^= q << 1; q ^= q << 2; q ^= q << 4;
    q ^= q & 0x80 ? 0x09 : 0;
    u8 xformed = ROTL8(q, 1) ^ ROTL8(q, 2) ^ ROTL8(q, 3) ^ ROTL8(q, 4);
    sbox[p] = q ^ xformed ^ 0x63;
  } while (p != 1);
  sbox[0] = 0x63;}
// Diffuse/compress.
S V mtprod(u32 r[16][16], u8 sbox[256]) {
  u32 temp[16][16] = { 0 };
  Fi(16, Fj(16,
    u32 sum = 0;
    Fk(16, sum += r[i][k] * sbox[k * 16 + j]);
    temp[i][j] = sum;))
  Fi(16, Fj(16, r[i][j] = temp[i][j]))}
S V mttrans(u32 r[16][16]) {
  u32 temp[16][16] = { 0 };
  Fi(16, Fj(16, temp[i][j] = r[j][i]))
  Fi(16, Fj(16, r[i][j] = temp[i][j]))}
S V mtcrypt(key * k[16], u8 padding[16], u8 sbox[256]) { // tr(R) = tr((R' * sbox)^r * sbox)
  u32 r[16][16]; Fi(16, Fj(16, r[i][j] = triple32(mtn(k[i])))) mtprod(r, sbox);
  Fi(16, rotl16(r[i], i)) mttrans(r); mtprod(r, sbox); Fi(16, padding[i] = ((r[i][i] >> 16) ^ r[i][i]) & 0xFF);}
// ========================================================
// Block cipher
// ========================================================
S V lagrange(u8 * x, u8 * y, int n, u8 * coef) {
  memset(coef, 0, n); // Data Compression in Depth, Kamila Szewczyk, pp. 288-290, O(n^2).
  u8 c[n + 1]; memset(c, 0, n + 1); c[0] = 1;
  for (int i = 0; i < n; i++) {
    for (int j = i; j > 0; j--)
      c[j] = c[j - 1] ^ M[c[j]][x[i]];
    c[0] = M[c[0]][x[i]]; c[i + 1] = 1;
  }
  u8 P[n]; memset(P, 0, n);
  for (int i = 0; i < n; i++) {
    u8 d = 1, t;
    for (int j = 0; j < n; j++)
      if (i != j) d = M[d][x[i] ^ x[j]];
    t = M[D[d]][y[i]];
    coef[n-1] ^= M[t][P[n-1] = 1];
    for (int j = n - 2; j >= 0; j--)
      coef[j] ^= M[t][P[j] = c[j+1] ^ M[x[i]][P[j+1]]];
  }
}
S u8 horner(u8 * coef, int n, u8 x) {
  u8 result = coef[n];
  for (int i = n - 1; i >= 0; i--)
    result = M[x][result] ^ coef[i];
  return result;
}
S V fiya(u8 vec[], int n, key * k[16]) {
  int sel = 0, j;
  Fid1(n, j = mtn(k[sel++ % 16]) % (i + 1); XCH(u8, vec[i], vec[j]))}
#define FIYA_EP u8 ep[224]; Fi(224, ep[i] = i + 32) fiya(ep, 224, k)
S V kc2bE(u8 blk[16], key * k[16], u8 sbox[256]) {
  u8 x[32], y[32], coef[32];
  Fi(32, x[i] = i) Fi(16, y[i] = blk[i]) mtcrypt(k, &y[16], sbox);
  lagrange(x, y, 32, coef);
  FIYA_EP; Fi(16, blk[i] = horner(coef, 31, ep[i]));}
S V kc2bD(u8 blk[16], key * k[16], u8 sbox[256]) {
  u8 x[32], y[32], coef[32];
  Fi(16, x[i] = i + 16) mtcrypt(k, y, sbox);
  FIYA_EP; Fi(16, x[i + 16] = ep[i], y[i + 16] = blk[i]) 
  lagrange(x, y, 32, coef);
  Fi(16, blk[i] = horner(coef, 31, i));}
// ========================================================
// File encryption/decryption
// ========================================================
S V kc2bEF(FILE * in, FILE * out, key * k[16]) {
  u8 sbox[256], buf[16] = { 0xAA };  initialize_sbox(sbox);
  long sz; while((sz = fread(buf, 1, 16, in)) > 0) {
    if (sz < 16) buf[15] = sz; kc2bE(buf, k, sbox);
    fwrite(buf, 16, 1, out);  memset(buf, 0xAA, 16);
  }}
S V kc2bDF(FILE * in, FILE * out, key * k[16]) {
  u8 sbox[256], buf1[16], buf2[16], sz;  initialize_sbox(sbox);
  if (fread(buf1, 16, 1, in) != 1) return;
  for (; fread(buf2, 16, 1, in) == 1; memcpy(buf1, buf2, 16)) {
    kc2bD(buf1, k, sbox);
    fwrite(buf1, 16, 1, out);
  }
  kc2bD(buf1, k, sbox); sz = buf1[15]; if (sz > 16) sz = 16; fwrite(buf1, sz, 1, out);}
// ========================================================
// Command-line stub.
// ========================================================
#define E(x) { fprintf(stderr, x); exit(1); }
S void keygen(FILE * out) {
  u8 buf[39936]; fread(buf, sizeof(buf), 1, rng); fwrite(buf, sizeof(buf), 1, out);}
S void keyget(FILE * in, key * k[16]) { // Big Endian?
  Fi(16, k[i]->mti = 0; fread(k[i]->mt, 624, 4, in))}
S FILE * xopen(const char * file, const char * mode) {
  FILE * f = fopen(file, mode); if(!f) { perror("fopen"); exit(1); } else return f;}
int main(int argc, char * argv[]) {
  init();
  if (argc < 2) E("kcrypt2b [-g/-e/-d] [FILES...]\n")
  if (!strcmp(argv[1], "-g")) {
    if (argc < 3) E("kcrypt2b -g key.kck\n");
    FILE * kf = xopen(argv[2], "wb");
    keygen(kf); fclose(kf);
  } else if (!strcmp(argv[1], "-e")) {
    if (argc < 4) E("kcrypt2b -e key.kck plaintext ciphertext\n")
    key * k[16]; Fi(16, k[i] = malloc(sizeof(key)))
    FILE * kf = xopen(argv[2], "rb"); keyget(kf, k); fclose(kf);
    FILE * plaintext = xopen(argv[3], "rb"), * ciphertext = xopen(argv[4], "wb");
    kc2bEF(plaintext, ciphertext, k);
    fclose(plaintext); fclose(ciphertext);
    Fi(16, free(k[i]));
  } else if (!strcmp(argv[1], "-d")) {
    if (argc < 4) E("kcrypt2b -d key.kck ciphertext plaintext\n")
    key * k[16]; Fi(16, k[i] = malloc(sizeof(key)))
    FILE * kf = xopen(argv[2], "rb"); keyget(kf, k); fclose(kf);
    FILE * ciphertext = xopen(argv[3], "rb"), * plaintext = xopen(argv[4], "wb");
    kc2bDF(ciphertext, plaintext, k);
    fclose(plaintext); fclose(ciphertext);
    Fi(16, free(k[i]));
  }
}
